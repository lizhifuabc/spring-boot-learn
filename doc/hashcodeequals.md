# equals规范

当创建类的时候，它自动继承自 Objcet 类。如果不覆写 equals() ，你将会获得 Objcet 对象的 equals() 函数。

默认情况下，这个函数会比较对象的地址。所以只有你在比较同一个对象的时候，你才会获得true。默认的情况是"区分度最高的"。

> 通常你会希望放宽这个限制。一般来说如果两个对象有相同的类型和相同的字段，你会认为这两个对象相等，但也会有一些你不想加入 equals() 函数中来比较的字段。这是类型设计的一部分。

# 关系

和equasl()方法作用类似，hashCode()也是用于比较两个对象是否相等。

# 写equals()方法的话一定要重写hashCode() 

1. 不用散列表

   如果说完全用不上散列表的类，换句话说这个类不会创建hashmap等等这些集合类，其实不重写也是可以的。

2. 需要使用到散列表的类
   1. hashCode()如果不相等，那说明两个对象肯定不可能相同
   2. hashCode()如果相等，此时可以再进行值得比较

> 所以如果这个类可能会创建散列表，重写了equals方法，就必须重写配套的hashcode方法，他们两个在散列表中是搭配使用

# 如何重写hashCode方法

> 核心是保证相同的对象能返回相同的hash值，不同的对象返回不同的hash值(hash冲突无法完全避免)。
>
> 这样就能保障hash值不一样的，值一定不相等，反过来只要再执行一遍equals方法就可以了